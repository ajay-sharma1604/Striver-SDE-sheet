Question1 

74 Search a 2D Matrix
https://leetcode.com/problems/search-a-2d-matrix/description/?submissionId=1250899578
//tc =0(n)
//sc- 0(1)

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
    
       int requiredRow = -1;
        for (int row = 0; row < matrix.length; row++) {
            if (matrix[row][matrix[row].length - 1] >= target) {
                requiredRow = row;
                break;
            }
        }

        // Target is smaller than all elements in the first column-target not exist
        if (requiredRow == -1) {
            return false; 
        }

        //searching in required row
        for(int i=0; i<matrix[requiredRow].length;i++){
            if(matrix[requiredRow][i]==target){
                return true;
            }
        }
        return false;  
}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Question2

50 Pow(x,n)
https://leetcode.com/problems/powx-n/

//t.c- O(logn)
//s.c-O(1)
class Solution {
    public double myPow(double x, int n) {
         if (n == 0) return 1;

        double res=1;
        long val =Math.abs((long)n);
         while(val>0){
           if((val&1)!=0){
            res=res*x;
           }
           x =x*x;
           val=val>>1;
        }
    
    return n<0 ? 1/res:res;
}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
question 3

169 Majority Element
https://leetcode.com/problems/majority-element/

//t.c- o(n), sc- o(n)

class Solution {
    public int majorityElement(int[] nums) {
        int ans =0;
       HashMap<Integer,Integer> map = new HashMap<>();
        
        for(int i=0; i<nums.length;i++){
            if (map.containsKey(nums[i])) {
                map.put(nums[i], map.get(nums[i])+1) ;     
            }
            else{
                map.put(nums[i], 1);
            }  
        }
        for (Integer key : map.keySet()) {
            if(map.get(key) > nums.length/2){
                ans =key;
        }
    }
    return ans;
}
}

//t.c- O(n), s.c- O(1)

class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        int candidate = 0;
        
        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            
            if (num == candidate) {
                count++;
            } else {
                count--;
            }
        }
        
        return candidate;
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Question 4

229 Majority Element II
https://leetcode.com/problems/majority-element-ii/

//t.c- O(n), s.c- O(n)

class Solution {
    public List<Integer> majorityElement(int[] nums) {
       
        List<Integer>ans =new ArrayList<>();
       HashMap<Integer,Integer> map = new HashMap<>();
        
        for(int i=0; i<nums.length;i++){
            if (map.containsKey(nums[i])) {
                map.put(nums[i], map.get(nums[i])+1) ;     
            }
            else{
                map.put(nums[i], 1);
            }  
        }
        for (Integer key : map.keySet()) {
            if(map.get(key) > nums.length/3){
                ans.add(key);
        }
    }
    return ans;
}
    }

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Question 5
62 Unique Paths
https://leetcode.com/problems/unique-paths/description/

//t.c- O(m*n)
//s.c= O(m*n)

class Solution {
     public int uniquePaths(int m, int n) { 
        int dp[][] =new int[m][n];
        return gridWays(m,n,dp);
    }

     public int gridWays(int m, int n, int dp[][]){
      for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(i==0||j==0){
                dp[i][j]=1;
        }
        else{
            dp[i][j]= dp[i-1][j] + dp[i][j-1];
        }
    }
 }
        return dp[m-1][n-1];
     }
   
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

